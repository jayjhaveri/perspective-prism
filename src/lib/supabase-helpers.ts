import { supabase } from '@/integrations/supabase/client';
import { Persona } from '@/types/perspective';

export const generatePersonas = async (topic: string) => {
  try {
    const { data, error } = await supabase.functions.invoke('generate-personas', {
      body: { input: topic }
    });

    if (error) throw error;

    return data.personas.map((p: any, index: number) => {
      return {
        id: p.persona_id,
        name: p.name,
        style: p.style,
        description: p.prompt,
        isCustom: false,
      };
    });
  } catch (error) {
    console.error('Error generating personas:', error);
    // Fallback to mock data if API fails
    return [
      {
        id: 'fallback-1',
        name: 'The Optimist',
        style: 'encouraging',
        description: 'Sees possibilities and silver linings in every situation.',
        isCustom: false,
      },
      {
        id: 'fallback-2',
        name: 'The Realist',
        style: 'practical',
        description: 'Focuses on facts, practical considerations, and realistic outcomes.',
        isCustom: false,
      },
      {
        id: 'fallback-3',
        name: 'The Devil\'s Advocate',
        style: 'critical',
        description: 'Challenges assumptions and points out potential problems.',
        isCustom: false,
      },
    ];
  }
};

export const saveDebateSession = async (
  topic: string,
  mode: 'standard' | 'debate',
  personas: Persona[]
) => {
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    throw new Error('User must be authenticated to save sessions');
  }

  // Create debate session
  const { data: debate, error: debateError } = await supabase
    .from('debates')
    .insert({
      user_id: user.id,
      topic,
      status: 'ongoing'
    })
    .select()
    .single();

  await supabase.from('messages').insert({
    debate_id: debate.debate_id,
    role: 'user',
    name: 'You',
    content: topic,
  });

  if (debateError) throw debateError;

  return debate;
};

// Create a new standard_interactions entry
export const createStandardInteraction = async (userId: string, input: string) => {
  const { data, error } = await (supabase as any)
    .from('standard_interactions')
    .insert({ user_id: userId, input })
    .select()
    .single();
  if (error) throw error;
  return data;
};

export const generateResponses = async (
  personas: Persona[],
  topic: string,
  interactionId: string // <-- add this param
) => {
  try {
    const { data: { user } } = await supabase.auth.getUser();

    const { data, error } = await supabase.functions.invoke('generate-responses', {
      body: {
        personas,
        topic,
        userId: user?.id,
        interactionId, // Pass interactionId if available
      }
    });

    if (error) throw error;

    // Convert to the format expected by the UI
    const responses: Record<string, string> = {};
    data.responses.forEach((response: any) => {
      responses[response.id] = response.response;
    });

    return responses;
  } catch (error) {
    console.error('Error generating responses:', error);
    // Fallback to mock responses
    const mockResponses: Record<string, string> = {};
    personas.forEach(persona => {
      mockResponses[persona.id] = `This is a mock response from ${persona.name} about "${topic}". In a real implementation, this would be generated by AI based on the persona's characteristics.`;
    });
    return mockResponses;
  }
};

export const loadUserHistory = async () => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return [];

  // Fetch debates (debate mode)
  const { data: debates, error: debatesError } = await supabase
    .from('debates')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false });
  if (debatesError) throw debatesError;

  // Attach personas to debates
  const debatesWithPersonas = await Promise.all(
    (debates || []).map(async (debate) => {
      const { data: personas } = await supabase
        .from('messages')
        .select('persona_id, name')
        .eq('debate_id', debate.debate_id)
        .not('persona_id', 'is', null)
        .not('name', 'is', null)
        .neq('role', 'user')
        .neq('role', 'system')
        .order('created_at', { ascending: true });
      const uniquePersonas = (personas || []).reduce((acc, curr) => {
        if (curr.persona_id && !acc.find((p) => p.persona_id === curr.persona_id)) {
          acc.push(curr);
        }
        return acc;
      }, []);
      return {
        ...debate,
        personas: uniquePersonas,
        mode: 'debate',
      };
    })
  );

  // Fetch standard interactions (standard mode)
  const { data: standards, error: standardsError } = await (supabase as any)
    .from('standard_interactions')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false });
  if (standardsError) throw standardsError;

  // Attach personas for standard mode (if any)
  const standardsWithMeta = await Promise.all(
    (standards || []).map(async (interaction: any) => {
      let uniquePersonas: any[] = [];
      console.log('Loading personas for interaction:', interaction);
      if (interaction.interaction_id) {
        const { data: personas } = await (supabase as any)
          .from('messages')
          .select('persona_id, name')
          .eq('interaction_id', interaction.interaction_id)
          .not('persona_id', 'is', null)
          .not('name', 'is', null)
          .neq('role', 'user')
          .neq('role', 'system')
          .order('created_at', { ascending: true });
        uniquePersonas = (personas || []).reduce((acc, curr) => {
          if (curr.persona_id && !acc.find((p) => p.persona_id === curr.persona_id)) {
            acc.push(curr);
          }
          return acc;
        }, []);
      }
      return {
        ...interaction,
        personas: uniquePersonas,
        mode: 'standard',
        topic: interaction.input, // for UI compatibility
        status: 'completed', // or 'ongoing' if you want to support that
        debate_id: null, // for UI compatibility
      };
    })
  );

  // Merge and sort by created_at
  const allHistory = [...debatesWithPersonas, ...standardsWithMeta].sort(
    (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  );

  return allHistory;
};

// For backward compatibility, you can export as loadUserDebates too
export { loadUserHistory as loadUserDebates };
